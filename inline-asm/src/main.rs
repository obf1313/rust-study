use std::arch::asm;

// https://course.rs/advance/unsafe/inline-asm.html
// 好难懂，没看完

fn main() {
    println!("Hello, world!");
    // 基本用法
    // 注意 unsafe 语句块依然是必不可少的，因为可能在里面插入危险的指令，最终破坏代码的安全性。
    unsafe {
        asm!("nop");
    }
    // 上面代码将插入一个 NOP 指令( 空操作 ) 到编译器生成的汇编代码中，其中指令作为 asm! 的第一个参数传入。

    // 输入和输出
    let x: u64;
    // 这段代码将 5 赋给 u64 类型的变量 x，值得注意的是 asm! 的指令参数实际上是一个格式化字符串。至于传给格式化字符串的参数，看起来还是比较陌生的:
    unsafe {
        // 首先，需要说明目标变量是作为内联汇编的输入还是输出，在本例中，是一个输出 out
        // 最后，要指定变量将要使用的寄存器，本例中使用通用寄存器 reg，编译器会自动选择合适的寄存器
        asm!("mov {}, 5", out(reg) x);
    }
    assert_eq!(x, 5);

    // 进一步使用了输入 in，将 5 加到输入的变量 i 上，然后将结果写到输出变量 o。
    // 实际的操作方式是首先将 i 的值拷贝到输出，然后再加上 5。
    let i: u64 = 3;
    let o: u64;
    unsafe {
        asm!(
            "mov {0}, {1}",
            "add {0}, 5",
            out(reg) o,
            in(reg) i,
        );
    }
    assert_eq!(o, 8);
}

// Rust 提供了 asm! 宏，可以让大家在 Rust 代码中嵌入汇编代码
// 对于一些极致高性能或者底层的场景还是非常有用的，例如操作系统内核开发
// 以下例子基于 x86/x86-64 汇编的，但是其它架构也是支持的，目前支持的包括：
// x86 和 x86-64
// ARM
// AArch64
// RISC-V
